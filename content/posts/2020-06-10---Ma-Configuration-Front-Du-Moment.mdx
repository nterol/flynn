---
title: Ma configuration front du moment
date: 2020-06-10T23:46:37.121Z
template: post
draft: false
slug: ma-configuration-front-du-moment
category: Tech Front
tags:
  - CSS-in-JS
  - styled components
  - Atomic Design
description: Comment je structure mes projets front en ce moment
socialImage: '/media/ma-config-front.jpg'
---

## üíÖ Les styled components

J'ai eu une grosse phase [styled-components üì¶](https://styled-components.com/) l'an dernier.

J'√©tais persuad√© que √ßa deviendrait la solution de styling pour toutes les app construites avec des framework/libraries JS. Et en soi je n'avais pas tort, beaucoup de sites utilisant React sont pass√©s dessus.

J'ai donc commenc√© √† faire des petites applications en styled-components et rapidement j'ai eu un soucis.
Le fait d'avoir du code ressemblant √† √ßa :

```jsx
const Container = styled.div`
  /** some style **/
`
const Row = styled.div`
  display: flex;
`

const Column = styled(Row)`
  flex-direction: column;
`

function MyComponent() {
  /* Some logic here */
  return (
    <Container>
      <Row>
        {myProps.map((e) => (
          <SomeOtherComponent key={e.name} {...e} />
        ))}
      </Row>
    </Container>
  )
}
```

Personnellement je n'aime pas ce genre de code parce qu'on ne voit plus le `html` que cela repr√©sente.

Certaines stacks utilisent un fichier √† part `styled.js` dont elles exportent un object `Styled`

ce qui donne des components ressemblant √† √ßa :

```jsx
function MyComponent() {
	return (
		<Styled.container>
			<Styled.row>
				{someprops.map(p => <Styled.listElement {...p} />)}
			</Styled.row>
		<Styled.container>
	);
}
```

Et je trouve qu'√† la longue, tous les composants finissent par se ressembler. La colorisation de ce genre de `component` n'est pas assez avanc√©e dans mon IDE, je n'ai pas envie de param√©trer √ßa et je ne suis m√™me pas sur que l'on puisse le faire. Travailler avec ces components devient difficile.

N√©anmoins toutes ces raisons ne suffisaient pas √† me passer de `styled-components`.
Le monde du Javascript repose en grande partie sur la Hype passag√®re de certaine librairie, jusqu'√† ce que quelqu'un s'√©l√®ve contre les trade-off de la dite librairie et propose une meilleure alternative.

Mon √©v√®nement d√©clencheur fut cet article, qui explique en d√©tail le fonctionnement des librairies css-in-js :

[The unseen performance costs of modern CSS-in-JS libraries in React apps](https://calendar.perfplanet.com/2019/the-unseen-performance-costs-of-css-in-js-in-react-apps/)

Beaucoup de librairies utilisent la fonctionnalit√© `ContextProvider` de React, fournissant une fonctionnalit√© via un state global √† l'application.
Bien √©videmment utiliser `ContextProvider` ne va pas sans certains d√©gradation des performances, notamment en provoquant des re-render inutiles.
C'est le cas aussi pour la plupart des librairies css-in-js qui proposent un `ThemeProvider` globale √† l'application.
En soi ce n'est pas un mal et en g√©n√©ral elles sont optimis√©es pour pouvoir √©conomiser ces re-render.

Mais cela suffit √† rendre l'application l√©g√®rement plus lourde qu'une application traditionnelle, en rajoutant une surcouche de javascript l√† ou ce n'est peut √™tre pas n√©cessaire.
Context Provider mis √† part, `styled[nomdutag]` reste une fonction JS qui va utiliser les arguments pass√©s en template string pour appeler un pr√©-processeur nomm√© [stylis üì¶](https://stylis.js.org/). Ce Pr√©processeur va ensuite injecter le CSS g√©n√©r√© dans le `html` puis mapper le bon hash de class vers le(s) bon components. Tout ceci rallonge la computation lors du re-render

Quelque soit la librairie css-in-js que vous utilisez il faut bien √† un moment que le js soit pr√©process√© en css.

Enfin je trouvais lourd de devoir √©crire des fonctions √† m√™me le pseudo css en passant les props. Ca marche. Et c'est grisant au d√©but. Mais je trouvais √ßa un poil over-kill.
La fonction `css` par ailleurs amenait pas mal de confusion, mais surtout la plupart des fonctionnalit√©s propre au css natif comme les filtres par exemple n'√©tait naturellement disponible dans `styled-components`. Non il fallait en plus installer [polished üì¶](https://polished.js.org/)

En fait `styled-components` fonctionne bien, et je pourrais √™tre amener √† le r√©utiliser si l'occasion s'en pr√©sentait. Mais je pense que l'on en a pas besoin dans la plupart des cas.

J'ai n√©anmoins fini par comprendre ce qui m'avait vraiment plu avec cette librairie : le scope.

## üî¨ Le scope

En utilisant styled-components on peut cr√©er un bloc de style r√©utilisable, combinable dans d'autre, mais en lui-m√™me isol√© du reste de la feuille de style, du moins durant le d√©veloppement.

Apr√®s avoir travaill√© sur des feuilles de styles structur√©es en `BEM` sans fin, li√©s les unes aux autres par des chemins myst√©rieux, avec des classes imbriqu√©s dans d'autres avec des mixins infinies, `styled-components` permettaient de profiter d'une simplicit√© et une rapidit√© dans le d√©veloppement.

Mais en fait il est possible de profiter de cette modularit√© de components simples et r√©utilisable.  
Avec les
Ce qui est fantastique c'est qu'aujourd'hui les stack react (`CRA`, `next.js` et `gatsby`) supportent par d√©faut les modules de css.

Du coup, comme pour les `styled-components` je peux avoir une fiche de style par component, avec des fiches globales de mixins (par exmple pour les breakpoints, les font-size et les couleurs de l'application), tout en profitant de template JSX plus clairs et des noms de classes apparents.
Bien sur on perd le dynamisme de l'utilisation des props √† m√™me le css, mais ne nous mentons. On utilise principalement cette fonctionnalit√© pour faire de simple ternaires. Et dans ce cas, autant utiliser [classnames üì¶](https://www.npmjs.com/package/classnames) qui permet de faire justement cela, et m√™me des assemblements complexes sans trop de prise de t√™te.

N√©anmoins m√™me avec √ßa, je n'√©tais toujours pas au clair sur l'organisation de mes fichiers. OK, j'ai un dossier `styles` rempli de fichiers tels que `Home.module.scss` et `Dropdown.module.scss` mais √ßa ne ressemble pas √ß grand chose, je vois pas trop comment √ßa scale, et surtout, la tentation de vouloir faire des abstractions avec tout ces fichiers proches les uns des autres - et donc recr√©er la situation que je mentionnais plus haut avec des pelotte de laine de scss imbriqu√©s- est trop grande.

Et c'est l√† que Brad Frost vient nous aider √† y voir plus clair.

## ‚öõÔ∏è Atomic Design

Brad Frost est un UX/UI developer qui a popularis√©, si ce n'est invent√© l'[organisation atomique du front end üìù](https://bradfrost.com/blog/post/atomic-web-design/)

En gros cela consiste √† pouvoir d√©couper toutes son application en composants, rien de neuf, puis √† les classer en plusieurs niveaux : `atoms`, `molecules`, `organisms`, `templates`, `pages`, chaque niveau √©tant id√©alement compos√© des niveaux pr√©c√©dents.

[composition d'app](https://www.notion.so/4158869b2d7e46c9a04b6112ce5e5cd4)

Cette m√©thode permet d'avoir une organisation rapide sur de petits projets, mais convient √©galement √† de plus large application.

### Inflation de la codebase et r√©utilisation des composants

J'ai d√©j√† travaill√© sur plusieurs grosses applications dans des domaines tr√®s diff√©rents. Pourtant toutes adoptaient une organisation de leur composants par appartenance par page, avec une fameuse section fourre tout nomm√©e `common` dans lequel on mettait tout ce qui n'allait pas ailleurs, ou qui allait partout. La justification de cette organisation √©tait que les besoins m√©tiers de chaque page sont radicalement diff√©rents, aussi chaque page a donc besoin de composants sp√©cialis√©s qui lui sont propres.

Le probl√®me de ce type de structure c'est qu'elle ne favorise pas du tout la r√©utilisation de l'existant. Et sous le pr√©texte fallacieux de besoins m√©tier, de nouveaux composants sont cr√©es, ce qui m√®ne √† une inflation de la codebase, et donc √† une acc√©l√©ration de la dette technique.

Acc√©l√©ration de la dette technique car un composant va √™tre utilis√© en priorit√© par rapport √† d'autre qui seront d√©laiss√©s. L'√©quipe change, les nouveaux arrivants ne comprennent pas les anciens composants, ne savent pas les utiliser certainement parce qu'√©crit avec des pr√©ceptes plus anciens, mais n'osent pas les supprimer parce qu'utilis√© ailleurs, probablement faisant appel √† un paquet d√©pr√©ci√© que l'on ose pas updater. Et ainsi la codebase se fossilise.

Cette excuse de la logique m√©tier est selon moins une fausse excuse d√ªe √† une m√©connaissance des librairies/framework modernes qui permettent g√©n√©ralement de d√©coupler ces logiques du rendu propre.
C'est notamment ce que permettent les hooks de React, et j'imagine qu'il doit √©galement y avoir des moyens de le faire sous vue ou svelte.

Si ce n'est pas le cas, il est peut √™tre temps de changer framework...

Cette d√©coupe "atomique" permet de favoriser ce d√©couplement logique/ui et ainsi de forcer √† r√©fl√©chir √† des composants mieux construits, plus g√©n√©raux dans les props n√©c√©ssaire √† son affichage.

C'est √©galement le moyen de r√©concilier l'ux designer de la boite avec les devs. Car c'est une fois ce d√©coupage mis en place et respect√© par l'ensemble de l'√©quipe front que [storybook üì¶](https://storybook.js.org/) prend tout son sens, et permet ensuite d'int√©grer des outils plus pouss√©s tels que [chromatic üîß](https://www.chromatic.com/docs/).

### ‚åõÔ∏è TLDR

`styled-components` c'est cool et hype, mais un poil overkill et peut rendre votre application lente.
D√©sormais pour n'importe quel projet front ax√© sur des composants - pas seulement React donc
j'utilise les `modules css` avec une architecture `atomic` et c'est le üî•.
